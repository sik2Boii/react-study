// 1. 원시 타입: Number, String, Boolean, Null, Undefined
// 값 자체가 변수에 저장되고, 복사될 때도 값이 그대로 복사됩니다.
// 불변값이다.(메모리 상에서 값이 변경되지 않음)
let p1 = 1; // 새로운 메모리에 값을 저장
let p2 = p1; // p1의 값을 복사하여 새로운 메모리에 저장
p2 = 2; // p2에 새로운 값을 할당, 이때 p1의 값은 변경되지 않음

// 2. 객체 타입: Object(Array, Function, RegExp)
// 참조값을 통해 변수에 저장되고, 복사될 때도 참조값이 복사됩니다.
// 가변값이다.(참조된 객체의 값이 수정될 수 있음)

// 2-1. 얕은 복사
// 객체의 참조값을 복사하기 때문에 원본 객체가 수정될 수 있어 주의가 필요합니다.
let o1 = { name: "엄준식" }; // 참조값 저장
let o2 = o1;

o2.name = "임준식"; // o2의 값을 변경하면 원본 객체 o1도 수정됩니다.

console.log(o1); // 결과: { name: "임준식" }

// 2-2. 깊은 복사
// 새로운 객체를 생성하여 프로퍼티를 복사하기 때문에 원본 객체가 수정되지 않아 안전합니다.
let o2V2 = { ...o1 }; // o1의 속성을 복사하여 새로운 객체 생성
o2V2.name = "엄준식"; // o2V2의 값을 변경해도 o1은 변경되지 않음

console.log(o1); // 결과: { name: "임준식" }
console.log(o2V2); // 결과: { name: "엄준식" }

// 3. 객체 타입 주의사항
// 3-1. 의도치 않게 값이 수정될 수 있습니다.
// 객체는 참조값을 통해 저장되므로, 하나의 객체를 여러 변수가 참조할 경우 의도치 않은 값의 변경이 발생할 수 있습니다.

// 3-2. 객체 간의 비교는 기본적으로 참조값을 기준으로 이루어집니다.
let obj1 = { name: "임준식" };
let obj2 = obj1; // 참조값 복사
let obj3 = { ...obj1 }; // 깊은 복사

// 얕은 비교 (참조값을 비교)
console.log(obj1 === obj2); // 결과: true (같은 객체를 참조)
console.log(obj1 === obj3); // 결과: false (서로 다른 객체)

// 깊은 비교 (객체의 속성 값을 비교)
console.log(
  JSON.stringify(obj1) === JSON.stringify(obj3) // JSON.stringify()는 객체를 문자열로 변환하여 비교
); // 결과: true (객체의 속성 값이 동일)

// JSON.stringify를 사용하면 객체의 내용 전체를 비교할 수 있어, 참조값 비교의 한계를 극복할 수 있습니다.

// 3-3. 배열과 함수도 사실 객체입니다.
// 배열과 함수는 객체 타입의 일종으로, 참조값을 통해 다루어집니다.
